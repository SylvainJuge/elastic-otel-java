import com.github.jk1.license.filter.LicenseBundleNormalizer
import com.github.jk1.license.render.TextReportRenderer

import java.nio.file.Files
import java.nio.file.StandardOpenOption

plugins {
  id "idea"
  id "maven-publish"
  id "base" // required to get 'clean' task
  alias(catalog.plugins.licenseReport)
  alias(catalog.plugins.nexusPublish)
}

group 'co.elastic.otel'

Properties versionProperties = new Properties()
versionProperties.load(new FileInputStream(file('version.properties')))
version = versionProperties.get("version")

description = "Elastic OpenTelemetry java distribution"

defaultTasks("agent:assemble")

subprojects {
  group = rootProject.group
  version = rootProject.version

  apply plugin: "java"
  apply plugin: "maven-publish" //Allows to run ./gradle publishToMavenLocal for easy local testing
  apply plugin: "com.diffplug.spotless"

  ext {
    deps = [
        autoservice: [
            "com.google.auto.service:auto-service:" + catalog.versions.autoservice.get(),
            "com.google.auto.service:auto-service-annotations:" + catalog.versions.autoservice.get(),
        ]
    ]
  }

  java {
    withJavadocJar()
    withSourcesJar()
  }

  repositories {
    mavenLocal()
    mavenCentral()
    maven {
      name = "mavenCentralSnapshots"
      url = uri("https://oss.sonatype.org/content/repositories/snapshots")
    }
  }

  spotless {
    java {
      target("src/**/*.java")
      googleJavaFormat()

      licenseHeaderFile(rootProject.file("buildscripts/spotless.license.java"), "(package|import|public)")
          .named("default")

      licenseHeaderFile(rootProject.file("buildscripts/spotless.reallogic.license.java"), "(package|import|public)")
          .named("reallogic")
          .onlyIfContentMatches("package co.elastic.otel.profiler.collections;")

    }
  }

  dependencies {

    implementation(platform(catalog.opentelemetryBom))

    // these serve as a test of the instrumentation boms
    implementation(platform(catalog.opentelemetryInstrumentationBom))
    implementation(platform(catalog.opentelemetryInstrumentationAlphaBom))

    testImplementation(catalog.mockito)

    testImplementation(enforcedPlatform(catalog.junitBom))
    testImplementation("org.junit.jupiter:junit-jupiter")
  }

  tasks {
    test {
      useJUnitPlatform()
    }

    compileJava {
      options.release.set(8)
    }
  }

  publishing {
    repositories {
      // dry-run repository will be wiped on 'clean' task
      maven {
        name = 'dryRun'
        url = rootProject.layout.buildDirectory.dir("dry-run-maven-repo")
      }
    }
  }
}

nexusPublishing {
  repositories {
    sonatype()
  }
}

task copyGitHooks(type: Copy) {
  from layout.projectDirectory.dir(".githooks")
  into layout.projectDirectory.dir(".git").dir("hooks")
}

task currentVersion {
  doLast {
    println project.version
  }
}

task setVersion {
  doLast {
    def versionFile = file('version.properties')
    versionFile.text = "version=${newVersion}\n"
  }
}

task setNextVersion {
  doLast {
    def versionFile = file('version.properties')
    def pattern = /version=(\d+\.\d+\.\d+)(-SNAPSHOT)?/
    versionFile.text = versionFile.text.replaceFirst(pattern) { match, version, suffix ->
      def (major, minor, patch) = version.split(/\./).collect { it as int }
      "version=${major}.${minor}.${patch + 1}-SNAPSHOT"
    }
  }
}

tasks.configure {
  doLast {
    copyGitHooks
  }
}

generateLicenseReport.doFirst {
  Files.list(rootDir.toPath().resolve("licenses"))
      .filter { f -> f.getFileName().endsWith(".jar") || f.getFileName().startsWith("NOTICE_") }
      .forEach { f ->
        delete f.toString()
      }
}

generateLicenseReport.doLast{
  // assemble the generated notice with Elastic header
  var licences = rootDir.toPath().resolve("licenses")


  var lines = new ArrayList<String>()
  lines.addAll(Arrays.asList(
      "Elastic OpenTelemetry Java Distribution",
      String.format("Copyright 2023-%d Elasticsearch B.V.", Calendar.getInstance().get(Calendar.YEAR)),
      "",
      "This project is licensed under the Apache License, Version 2.0 - https://www.apache.org/licenses/LICENSE-2.0",
      "An embedded copy of the Apache License, Version 2.0 is provided below.",
      "",
      "This project depends on ASM which is licensed under the 3-Clause BSD License - https://opensource.org/licenses/BSD-3-Clause",
      "An embedded copy of the ASM license (3-Clause BSD License) is provided below.",
      "",
      "This project depends on okhttp, which contains 'publicsuffixes.gz' that is licensed under the Mozilla Public License, v. 2.0 - https://mozilla.org/MPL/2.0/",
      "An embedded copy of the publicsuffixes.gz license (Mozilla Public License, v. 2.0) is provided below.",
      ""))

  lines.addAll(Arrays.asList("","###### Apache License, Version 2.0", ""))
  lines.addAll(Files.readAllLines(rootDir.toPath().resolve("LICENSE")))

  lines.addAll(Arrays.asList("","###### ASM 3-Clause BSD License", ""))
  lines.addAll(Files.readAllLines(licences.resolve("asm_bsd-3-clause")))

  lines.addAll(Arrays.asList("","###### publicsuffixes.gz Mozilla Public License, v. 2.0", ""))
  lines.addAll(Files.readAllLines(licences.resolve("publicsuffixes_mpl-2")))

  lines.addAll(Arrays.asList("","###############################################################################"))

  lines.addAll(Files.readAllLines(licences.resolve("NOTICE_dependencies")))

  Files.write(rootDir.toPath().resolve("NOTICE"), lines)
}

licenseReport {
  outputDir = "$projectDir/licenses"
  renderers = [new TextReportRenderer("NOTICE_dependencies")]
  excludeBoms = true
  excludes = [
        "io.opentelemetry:opentelemetry-bom-alpha",
        "io.opentelemetry.instrumentation:opentelemetry-instrumentation-bom-alpha"
  ]
  filters = [new LicenseBundleNormalizer(bundlePath: "$projectDir/buildscripts/license-normalizer-bundle.json")]
  projects = [rootProject, rootProject.project("agent"), rootProject.project("bootstrap"),
              rootProject.project("common"), rootProject.project("custom"),
              rootProject.project("inferred-spans"), rootProject.project("instrumentation"),
              rootProject.project("resources"), project]
  configurations = ['runtimeClasspath', 'compileClasspath']

}
